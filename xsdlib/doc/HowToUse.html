<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>USAGE GUIDE FOR THE XSDLib, SUN'S JAVA IMPLEMENTATION OF XML SCHEMA PART 2</TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.2 (Solaris Sparc)">
	<META NAME="CREATED" CONTENT="20010322;14525300">
	<META NAME="CHANGEDBY" CONTENT="Eduardo Gutentag">
	<META NAME="CHANGED" CONTENT="20010322;15064500">
	<style>
		.title
		{
			text-align:center;
			font-weight:bold;
		}
		PRE
		{
			background-color: rgb(240,240,240);
		}
	</style>
</HEAD>
<BODY>
<P ALIGN=center STYLE="MARGIN-BOTTOM: 0in"><B> USAGE GUIDE FOR
XSDLib, SUN'S JAVA IMPLEMENTATION OF XML SCHEMA PART 2<BR>Preview Version.1
March, 2001<BR><BR>Copyright (c) Sun Microsystems, 2001</B></P>
<P STYLE="MARGIN-BOTTOM: 0in"><BR>
</P>
<P ALIGN=right>Document written by <A href="mailto:kohsuke.kawaguchi@eng.sun.com">Kohsuke
KAWAGUCHI</A> <BR>$Id: HowToUse.html,v 1.3 2001/03/19 20:12:30 Bear
Exp $ 
</P>
<P>XSDLib, Sun's Java Implemantation of XML Schema Part 2, is
intended for use by application developers as a building block.</P>
<H1>Contents of This Document</H1>
<OL>
	<LI><P STYLE="MARGIN-BOTTOM: 0in"><A href="#intro">Introduction</A> 
	</P>
	<LI><P STYLE="MARGIN-BOTTOM: 0in"><A href="#derivation">Deriving A
	New Type</A> 
	</P>
	<LI><P STYLE="MARGIN-BOTTOM: 0in"><A href="#diagnosis">Diagnosing
	Errors</A> 
	</P>
	<LI><P><A href="#misc">Miscellaneous Notes</A> 
	</P></LI>
</OL>
<H1><A NAME="intro"></A>Introduction: Validating Strings</H1>
<P>The following example validates a string with integer datatype.</P>
<PRE>void f( String v ) {
  // obtain a type object
  DataType dt = DataTypeFactory.getTypeByName("integer");
  // validates a type
  if( dt.verify(v,null) )
    ; // v is a valid integer
  else
    ; // v is not a valid integer
}</PRE><P>
Several types are context-dependent. For example, the "QName"
type, which validates something like "prefix:localPart",
neeeds to know that the given prefix is properly declared. 
</P>
<P>This information must be supplied to DataType object by the
caller. To do this, the caller must provide an object that implements
the ValidationContextProvider interface and pass it as the second
parameter of the verify method. 
</P>
<PRE>class MyContextProvider implements ValidationContextProvider
{
  String resolveNamespacePrefix( String prefix ) {
    // resolves namespace prefix to namespace URI.
  }

  boolean isUnparsedEntity( String entityName ) {
    // checks if given name is a valid entity name.
  }
}

void f( String v, MyContextProvider context ) {
  // obtain a type object
  DataType dt = DataTypeFactory.getTypeByName("QName");
  // validates a type
  if( dt.verify(v,contest) )
    ; // v is a valid QName
  else
    ; // v is not a valid QName
}</PRE><P>
Although the first example passes null as a
ValidationContextProvider, the caller must ALWAYS provide a valid
ValidationContextProvider for XSDLib to work correctly. 
</P>
<H1><A NAME="derivation"></A>Deriving A New Type</H1>
<H2>By List</H2>
<P>The following example derives a new type from an existing DataType
object by list. 
</P>
<PRE>DataType deriveByList( DataType itemType ) throws BadTypeException {
  return DataTypeFactory.deriveByList("myType",itemType);
}</PRE><P>
The first parameter 
specifies the name of the newly created type. Note that these
derived types cannot be found through the getTypeByName method of
DataTypeFactory class. 
</P>
<P>When an error is found during derivation, a BadTypeException will
be thrown. For example, if you derive a type by list from list type,
an exception will be thrown. 
</P>
<H2>By Union</H2>
<P>The following example derives a new type from existing DataType
objects by union. 
</P>
<PRE>DataType deriveByUnion( DataType[] memberTypes ) throws BadTypeException {
  return DataTypeFactory.deriveByUnion("myType",memberTypes);
}</PRE><P>
The only difference between derivation by list and derivation by
union is that the latter accepts more than one base type. 
</P>
<H2>By Restriction</H2>
<P>The following example derives a new type by adding facets. 
</P>
<PRE>DataType f() throws BadTypeException {
  DataType baseType = DataTypeFactory.getTypeByName("string");
  
  // create a type incubator with the base type
  TypeIncubator incubator = new TypeIncubator(baseType);
  
  // add facets
  incubator.add( "minLength", "5", false, null );
  incubator.add( "maxLength", "20", false, null );
  
  // derive a new type by those facets
  DataType derived = incubator.derive("newTypeName");
  
  return derived;
}</PRE><P>
The third parameter to the add method specifies whether that facet
should be "fixed" or not. Once a facet is fixed, a derived
class can no longer restrict that facet. 
</P>
<P>The fourth parameter is again ValidationContextProvider, which is
sometimes necessary. Although the above example does not supply one,
the caller has to supply an object that implements
ValidationContextProvider. 
</P>
<P>BadTypeException can be thrown when you add a facet or when you
call the derive method. 
</P>
<H1><A NAME="diagnosis"></A>Diagnosing Errors</H1>
<P>The following example provides a diagnostic message to users about
what is wrong with their value. 
</P>
<PRE>void test( DataType dt, String v, ValidationContextProvider context ) {
  if( dt.verify(v,context) )
    System.out.println("valid");
  else {
    try {
      DataTypeDiagnosis d = dt.diagnose(v,context);
      // print diagnosis message
      System.out.println("invalid: "+d.getMessage());
    }
    catch( NotSupportedOperationException e ) {
      // data type may not support diagnosis.
      System.out.println("invalid");
    }
  }
}</PRE><P>
In this way, the user gets informative error messages. If the
DataType object does not support diagnosis, it throws
NotSupportedOperationException. It is the caller's responsibility to
handle this exception correctly. 
</P>
<H1><A NAME="misc"></A>Miscellaneous Notes</H1>
<H2>DataType interface</H2>
<P>The DataType interface is NOT intended to be used as a general
interface for datatype vocabularies. This interface is strongly
coupled with XSD. Providing a generic interface that can be used by
various full-fledged datatype vocabularies is not trivial. 
</P>
<P>In order to overcome this shortcoming in the current release of
XSDLib, developers wishing to implement their own type that
implements Datatype should do so by deriving their class from
<CODE>ConcreteType</CODE> class.</P>
</BODY>
</HTML>