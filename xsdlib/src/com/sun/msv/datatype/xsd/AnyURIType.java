/*
 * @(#)$Id$
 *
 * Copyright 2001 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * This software is the proprietary information of Sun Microsystems, Inc.  
 * Use is subject to license terms.
 * 
 */
package com.sun.tranquilo.datatype;

import java.io.ByteArrayInputStream;

/**
 * "anyURI" type.
 * 
 * See http://www.w3.org/TR/xmlschema-2/#anyURI for the spec.
 * value object of "anyURI" type is escaped URI.
 * 
 * @author Kohsuke KAWAGUCHI
 */
public class AnyURIType extends ConcreteType implements Discrete
{
	public static final AnyURIType theInstance = new AnyURIType();
	private AnyURIType() { super("anyURI"); }
	
	protected boolean checkFormat( String content, ValidationContextProvider context )
	{
		return convertToValue(content,context)!=null;
	}

	private static void appendHex( StringBuffer buf, int hex )
	{
		if( hex<10 )	buf.append( (char)(hex+'0') );
		else			buf.append( (char)(hex-10+'A') );
	}
	private static void appendByte( StringBuffer buf, int ch )
	{
		buf.append('%');
		appendHex( buf, ch/16 );
		appendHex( buf, ch%16 );
	}
	private static void appendEscaped( StringBuffer buf, char ch )
	{// convert one 'char' in BMP to UTF-8 encoding
		if( ch<0x7F )
		{
			appendByte(buf,(int)ch);
			return;
		}
		if( ch<0x7FF )
		{
			appendByte(buf, 0xC0 + (ch>>6));
			appendByte(buf, 0x80 + (ch%64));
			return;
		}
		if( ch<0xFFFF )
		{
			appendByte(buf, 0xE0 + (ch>>12) );
			appendByte(buf, 0x80 + ((ch>>6)%64) );
			appendByte(buf, 0x80 + (ch%64) );
		}
	}
	private static void appendEscaped( StringBuffer buf, char ch1, char ch2 )
	{// convert one surrogate pair to UTF-8 encoding
		int ucs = (((int)(ch1&0x3FF))<<10) + (ch2&0x3FF);
		
		appendByte(buf, 0xF0 + (ucs>>18) );
		appendByte(buf, 0x80 + ((ucs>>12)%64) );
		appendByte(buf, 0x80 + ((ucs>> 6)%64) );
		appendByte(buf, 0x80 + (ucs%64) );
	}
	
	/**
	 * a table that indicates whether a particular character has to be
	 * escaped or not. false indicates it has to be escaped.
	 * this table is of length 128.
	 */
	private static final boolean[] isUnreserved = createUnreservedMap();
	private static boolean[] createUnreservedMap()
	{
		boolean r[] = new boolean[128];
		
		for( int i='a'; i<='z'; i++ )	r[i] = true;
		for( int i='A'; i<='Z'; i++ )	r[i] = true;
		for( int i='0'; i<='9'; i++ )	r[i] = true;
		
		char[] mark = new char[]{'-','_','.','!','~','*','\'','(',')','#','%','[',']'};
		for( int i=0; i<mark.length; i++ )
			r[mark[i]] = true;
		
		return r;
	}
	
	
	/** escape non-ASCII characters in URL */
	public static String escape( String content )
	{
		StringBuffer escaped = new StringBuffer(content.length());
		for( int i=0; i<content.length(); i++ )
		{
			char ch = content.charAt(i);
			if( ch<128 && isUnreserved[ch])
				escaped.append(ch);
			else
			{// escape it
				if( 0xD800 <= ch && ch < 0xDC00 )	// surrogate pair
					appendEscaped( escaped, ch, content.charAt(++i) );
				else	// other characters.
					appendEscaped( escaped, ch );
			}
		}
		return new String(escaped);
	}

	public Object convertToValue( final String content, ValidationContextProvider context )
	{
		// we can't use java.net.URL (for example, it cannot handle IPv6.)
		
		// TODO: directly create byte[]
		String escaped = escape(content);
		
		try
		{// make sure it conforms [RFC2396] (amended by [RFC2732])
			// parser generated by javacc reads a byte sequence, not a character sequence.
			// thus we have to somehow convert a character sequence to a byte sequence.
			
			// currently, URI only accepts US-ASCII characters (#x0-#x7F)
			// (note that this is a priority-feedback item of current draft, so
			// possibility of change is very high)
			
			// By using UTF-8, non ascii characters will have bit image of 1XXXXXXX.
			// thus these characters will be rejected by the parser as an error.
			final AnyURIParser parser =
				new AnyURIParser( new ByteArrayInputStream( escaped.getBytes("UTF8") ) );
			parser.start();
		}
		catch( Throwable e )
		{// JavaCC throws Error-derived classes in case of errors, so we have to catch them.
			return null;
		}
		
		// the value space and the lexical space is the same.
		// escaped characters are only used for validation.
		return content;
	}
	

	public final int isFacetApplicable( String facetName )
	{
		if( facetName.equals(FACET_LENGTH)
		||	facetName.equals(FACET_MINLENGTH)
		||	facetName.equals(FACET_MAXLENGTH)
		||	facetName.equals(FACET_PATTERN)
		||	facetName.equals(FACET_ENUMERATION) )
			return APPLICABLE;
		else
			return NOT_ALLOWED;
	}
	
	public final int countLength( Object value )
	{
		// the spec does not define this.
		// TODO: check the update of the spec and modify this if necessary.
		return UnicodeUtil.countLength( (String)value );
	}
}
