<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="Tahiti.xsl" ?>
<article>
<articleinfo>
	<releaseinfo>$Id$</releaseinfo>
	<title>Tahiti User's Guide</title>
	<editor>
		<surname>KAWAGUCHI</surname>
		<firstname>Kohsuke</firstname>
		<affiliation>
			<address>
				<email>kohsuke.kawaguchi@sun.com</email>
			</address>
		</affiliation>
	</editor>
	<copyright>
		<year>2001</year>
		<holder>Sun Microsystems</holder>
	</copyright>
	<legalnotice><para>
			Sun internal use only.
	</para></legalnotice>
	<abstract><para>
			This document describes the general usage of Tahiti.
	</para></abstract>
</articleinfo>
<section>
	<title>Getting Started</title>
	
	<para>
		First, you need a grammar. Tahiti supports various schema language,
		but let's assume you have "foo.rng" file as your grammar.
		Then the first thing you should do is to run the schema compiler.
	</para>
	<screen><![CDATA[>java Compiler foo.rng]]></screen>
	<para>
		Schema compiler will generate Java source codes to the current directory.
		If you want it to place those files to another directory, then you can use
		the <userinput>-d</userinput> option like this:
	</para>
	<screen><![CDATA[>java Compiler foo.rng -d ../../src]]></screen>
	
	<para>
		Although the compiler takes every effort to extract a meaningful mapping from the schema,
		often it falls short of your expectation.
		
		If that is the case, you can control the way
		the compiler maps schemas to Java classes 
		by annotating schema files.
	</para><para>
		The annotation depends on the schema language you use. Consult the documentation
		for your choice of the schema language.
	</para>
	<itemizedlist>
		<listitem><para><ulink url="RELAX NG Bind.html">
			RELAX NG annotation
		</ulink></para></listitem>
	</itemizedlist>
</section>


<section>
	<title>Using the generated classes</title>
	
	<para>
		This section describes how you can use the genrated Java classes to do what you want.
	</para><para>
		You should know two important operations involving the generated classes.
		One is <emphasis>marshalling</emphasis> and the other is
		<emphasis>unmarshalling</emphasis>
	</para>
	
	<section>
		<title>Unmarshalling</title>
		
		<para>
			Unmarshalling is the process that reads an XML document and creates the corresponding
			Java objects. The easiest way to do this is to do as follows:
		</para>
<programlisting><![CDATA[
import org.example.test.Grammar;

class Main {
  public static void main() {
    // specify URL
    MyClass o1 = Grammar.unmarshall("file://abc/def.xml");
    // specify org.xml.sax.InputSource
    MyClass o2 = Grammar.unmarshall(new InputSource(new FileInputStream(...)));
  }
]]></programlisting>
		<para>
			The above method will read the document from the specified location and returns
			the result.
		</para><para>
			<classname>org.example.test.Grammar</classname> is the name of
			the compiled grammar, which is generated by the schema compiler.
			You should replace it with appropriate class name.
		</para><para>
			Another overloaded version of this method accepts
			<classname>org.xml.sax.InputSource</classname> as the parameter.
		</para><para>
			Should any error happens during the process of unmarshalling, an exception
			is thrown. See javadoc for details.
		</para>
	</section>
	
	
	<section>
		<title>Marshalling</title>
		
		<para>
			At this moment, marshalling is not implemented.
		</para>
	</section>
</section>
</article>
