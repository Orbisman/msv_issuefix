<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>MSV Developer's Guide</TITLE>
	<style>
		.title {
			text-align:center;
			font-weight:bold;
		}
		PRE {
			background-color: rgb(240,240,240);
		}
		P {
			margin-left: 2em;
		}
		PRE {
			margin-left: 4em;
			margin-right:4em;
		}
		DL {
			margin-left: 2em;
		}
		DT {
			margin-top: 0.5em;
			font-weight: bold;
		}
	</style>
</HEAD>
<BODY>
<P ALIGN=center STYLE="MARGIN-BOTTOM: 0in">
  <B>DEVELOPER'S GUIDE TO SUN'S MULTI-SCHEMA VALIADTOR<BR>
  Preview Version.1 April, 2001<BR>
  <BR>
  Copyright &copy; Sun Microsystems, 2001</B>
  </P>
<P><BR></P>

<P ALIGN=right>
 Document written by <A href="mailto:kohsuke.kawaguchi@eng.sun.com">Kohsuke KAWAGUCHI</A><BR>
 $Id$ 
</P>
<P>
  Sun's Mutli-Schema Validator is  a Java tool to validate XML documents against
  XML schemata. It supports RELAX Namespace, RELAX Core, TREX, XML DTD,
  and a subset of W3C XML Schema Part 1.
</P>



<H1>Table Of Contents</H1>
<OL>
  <LI><A href="#overview">Design Overview</A></LI> 
  <LI><A href="#qs">Quick Start</A></LI> 
  <LI><A href="#load">Loading Schemata</A></LI> 
  <LI><A href="#agm">Playing with AGM</A></LI> 
    <OL>
      <LI><A href="#agm_dep">Schema Language Dependency</A></LI> 
      <LI><A href="#agm_exps">Expression and ExpressionPool</A></LI> 
      <LI><A href="#agm_create">Creating AGM from scratch</A></LI> 
      <LI><A href="#agm_access">Accessing AGM</A></LI> 
      <LI><A href="#agm_modify">Manipulating AGM</A></LI> 
    </OL>
  <LI><A href="#controller">Controlling Parsing of Schemata</A></LI> 
  <LI><A href="#validate">Validating Documents</A></LI> 
    <OL>
      <LI><A href="#vgm">VGM</A></LI> 
      <LI><A href="#thread">Multithread Environment</A></LI> 
      <LI><A href="#daemon">Daemon Process</A></LI> 
    </OL></LI>
  <LI><A href="#type">Type Assignment</A></LI> 
    <OL>
      <LI><A href="#trexext">TREX extension</A></LI> 
    </OL></LI>
</OL>

<A id="overview" />
<H1>Design Overview</H1>
<P>MSV consists of six components.</P>
<DL>
	<DT>Abstract grammar model (AGM):</DT>
	<DD>
		schema-independent grammar model.
		All supported schemata are parsed into this internal representation.
		This model, coupled with the grammar reader, may be useful for other applications.
	</DD>
	<DT>Grammar reader:</DT>
	<DD>
		a component used to parse schemata by using SAX to construct AGM.
	</DD>
	
	<DT>Verification grammar model (VGM):</DT>
	<DD>
		a bridge between AGM and Validator. It works as an abstraction layer between them,
		thereby makeing non-automaton-based algorithms possible.
	</DD>
	
	<DT>Validator:</DT>
	<DD>
		a component to validate an XML instance with VGM by using SAX.
	</DD>
	
	<DT>Datatype validator: </DT>
	<DD>
		a component separately available as the Sun XML Datatypes Library.
	</DD>
	
	<DT>RELAX Namespace ("divide&amp;validate" framework):</DT>
	<DD>
		a component that allows multiple schema languages to cooperatively validate
		one instance. <i>The mplementation of this component is likely to change substantially in
		the future.</i>
	</DD>
</DL>
  
  
<A id="qs" />
<H1>Quick Start: validating documents</H1>
<P>
  You can use MSV to validate documents before your application reads them.
  If this satisfies your needs, then this section is the only section you have to read.
</P>
<P>
  The easiest way to do this is to 
  use "Java API for RELAX Verifiers" (JARV). JARV is an implementation-independent 
  interface set, so you can even switch to a different verifier implementation if 
  you like. For information about JARV,
  see <a href="http://iso-relax.sourceforge.net/">http://iso-relax.sourceforge.net/</a>.
</P>
<P>
  Despite its name, JARV is not limited to RELAX; it can be used with TREX.
  The following example illustrates a typical usage of JARV.
</P>
<PRE>
import org.iso_relax.verifier.*;
import javax.xml.parsers.SAXParserFactory;

void f( SAXParserFactory pf )
{
  // parser factory has to be configured to be namespace aware.
  pf.setNamespaceAware( true );
  
  // create a VerifierFactory
  // <b>if you'd like to use TREX schema, then </b>
  // <b>create TREXFactoryImpl instead of RELAXFactoryImpl in the above line</b>
  VerifierFactory factory = new com.sun.msv.verifier.jarv.RELAXCoreFactoryImpl(pf);
  
  // load RELAX schema
  Verifier verifier = factory.newVerifier( new File("foo.rxg") );
  
  try {
    if( !verifier.isFeature(FEATURE_FILTER) )
      return;  // this verifier doesn't support getVerifierFilter method.
  } catch( org.xml.SAXNotRecognizedException e )
  {  return; } // this verifier doesn't support getVerifierFilter method.
  
  // obtain XMLFilter
  VerifierFilter filter = verifier.getVerifierFilter();
  
  // parse a document
  filter.setParent( pf.newSAXParser().getXMLReader() );
  filter.setContentHandler( new MyContentHandler() );
  filter.parse( "MyInstance.xml" );
  
  if( filter.isValid() )
    // the document was valid
  else
    // the document was not valid
}
</PRE>
<P>
  VerifierFilter validates the document before your ContentHandler receives
  SAX events. You can call the <code>isValid</code> method of VerifierFilter to
  check the validity of the document.
</P>
<P>
  Currently, there is no way to use DOMBuilder with JARV.
</P>



<A id="load" />
<H1>Loading Schemata</H1>
<P>
  If you need finer control, then you may want to control MSV directly
  instead of using the generic JARV interface.
  This section and following sections will focus on the direct use of MSV.
</P>
<P>
  The easiest way to load a grammar is to use the loadSchema method of
  <code>com.sun.msv.reader.util.GrammarLoader</code>.
</P>
<PRE>
Grammar loadGrammar( String schemaFileNameOrURL )
{
  SAXParserFactory factory = new javax.xml.parsers.SAXParserFactory();
  // or you can use different parser like Xerces-J by
  // <b>new org.apache.xerces.parsers.jaxp.SAXParserFactoryImpl();</b>

  factory.setNamespaceAware(true);
  
  return GrammarLoader.loadSchema(
                        schemaFileNameOrURL,
                        new com.sun.msv.reader.util.IgnoreController(),
                        factory );
}
</PRE>
<P>
  GrammarLoaded automatically detects the type of schema (RELAX Core/TREX/RELAX Namespace/W3C)
  and handles it appropriately.
  
  The second 
  parameter specifies a "controller" object that receives notifications and controls 
  the loading behavior. <code>IgnoreController</code> does nothing,
  but by providing a different object, you can control the parsing
  process.
  
  The third parameter specifies SAXParserFactory to be used.
  Factory has to be configured as namespace aware.
</P>
<P>
  Alternatively, to load a specific language,
</P>
<PRE>
import com.sun.msv.grammar.Grammar;
import com.sun.msv.reader.util.GrammarLoader;
import javax.xml.parsers.SAXParserFactory;

TREXGrammar loadTREX( String schemaFileNameOrURL )
{
  SAXParserFactory factory = new javax.xml.parsers.SAXParserFactory();
  factory.setNamespaceAware(true);
  
  return TREXGrammarReader.parse(
                        schemaFileNameOrURL,
                        factory,
                        new com.sun.msv.reader.util.IgnoreController() );
}
</PRE>
<P>
  The parse method also accepts several other forms of arguments (e.g., InputSource).
  If loading fails, the parse method returns null. 
</P>
<P>
  In this way, you can parse the XML representation of the specific language into MSV's AGM.
</P>
<P>
  Since XML DTDs are not written in XML format, they have to be parsed differently.
  To parse an XML DTD, do as follows
</P>
<PRE>
Grammar loadDTD( String schemaFileNameOrURL )
{
  return DTDReader.parse(
    new InputSource(schemaFileNameOrURL),
    new com.sun.msv.reader.util.IgnoreController() );
}
</PRE>
<P>
  The first parameter specifies the InputSource object from which the DTD is read.
  The second paramter controls the parsing behavior.
  Currently, MSV cannot parse an internal DTD subset.
</P>



<A id="agm" />
<H1>Playing with AGM</H1>
<P>
  AGM is the internal representation of a schema used by MSV.
  It is a binarized regular expression commonly seen in many validating processors.
</P>

<A id="agm_dep" />
<H2>Schema Language Dependency</H2>
<P>AGM consists of four parts.</P>
<OL>
	<LI>
		<STRONG>Core:</STRONG> common part of TREX and RELAX. e.g., ChoiceExp, 
		SequenceExp, MixedExp, and more. Also contains several abstract classes 
		(ReferenceExp and ElementExp).
	<LI>
		<STRONG>TREX extension:</STRONG> primitives introduced for 
		TREX: InterleavePattern and ConcurPattern.
	<LI>
		<STRONG>language-specific stubs:</STRONG>
		concrete implementations of abstract classes
		and composite expressions of the specific language.
</OL>
<P>
	TREX introduces several language primitives that are not available in other languages.
	These primitives are placed in the TREX extension part. AGMs constructed from TREX 
	grammars may contain those primitives. AGMs from RELAX never contain TREX extension primitives.
</P>
<P>
	You should also note that the AGM is designed to handle differences between schema languages.
</P>
<UL>
	<LI>
		Reference to another part of the grammar. Most of the schema languages
		have a mechanism to name declarations and refer to them by name from other locations.
		TREX has only one mechanism (&lt;ref&gt;&amp;&lt;define&gt;), whereas
		RELAX has four separate definitions/references 
		(&lt;tag&gt;, &lt;attPool&gt;, &lt;hedgeRule&gt;, &lt;elementRule&gt; and 
		&lt;ref&gt;, and &lt;hedgeRef&gt;).
		W3C XML Schema has six distinct mechanisms.
		To handle the difference, the core part provides abstract ReferenceExp 
		class, which is used as the base class that represents the referencable declaration.
		Language stubs then derive RefenreceExp and provide concrete implementations.
	<LI>
		Constraint of tag name. RELAX constrains tag name by &lt;tag&gt; 
		declaration, which is in turn referenced by &lt;elementRule&gt; declaration. TREX 
		constrains tag name by element declaration itself. So RELAX has one more
		abstraction layer between constraint over element and that over tag 
		name. To handle such difference, the core part provides
		abstract ElementExp class, and stubs provide 
		concrete implementations respectively.
</UL>
<P>
	Generally speaking, you may want to avoid dependency on the stub parts. If 
	your code only depends on the core part and the TREX extension, your code 
	will work with AGMs created from any language.
	<code> com.sun.msv.verifier.regexp </code> is one of such code that works with any AGM.
</P>


<A id="agm_exps" />
<H2>Expression and ExpressionPool</H2>
<P>
  Expression and most of the derived classes are immutable, and they have to be
  created through ExpressionPool.
  Internally, every Expression is memorized by ExpressionPool
  so that sub expressions can be shared and reused.
</P>
<P>
  Mixing two expressions created from two different pools is possible, but not recommended.
  If you are going to use MSV in a multithreaded environment, or
  you are going to use it in a daemon process, see <a href="#thread">"Multithreaded Environment"</a>
  and <a href="#daemon">"Daemon Process"</a> respectively.
</P>



<A id="agm_create" />
<H2>Creating AGM from scratch</H2>
<P>
	RELAXCoreReader/TREXGrammarReader/RELAXNSReader/XMLSchemaReader/DTDReader is just one way to create 
	an AGM. Alternatively, you can create it from scratch.
</P>
<PRE>
import com.sun.msv.grammar.trex.*;
import com.sun.msv.grammar.*;

TREXGrammar create()
{
  TREXPatternPool pool = new TREXPatternPool();
  TREXGrammar g = new TREXGrammar(pool); // create an empty grammar
	  
  g.start = new ElementPattern(
    // name class that constrains tag name
    new SimpleNameClass("http://namespace.uri/","tagname"),
    // content model
      pool.createMixed(
        pool.createSequence(
          new ElementPattern(
            new SimpleNameClass("http://namespace.uri/","tagname2"),
            pool.createEpsilon() // empty
          ),
          pool.createAttribute(
            new SimpleNameClass("","attr"),
            pool.createAnyString()
          )
        )
      )
    );
  // ElementPatterns are created outside ExpressionPool
  
  return g;
}
</PRE>
<P> 
  The AGM created by the above example is equivalent to the following TREX grammar.
</P>
<PRE>
&lt;element name="tagname" ns="http://namespace.uri/"&gt;
  &lt;mixed&gt;
    &lt;group&gt;
      &lt;element name="tagname2"&gt;
        &lt;empty /&gt;
      &lt;/element&gt;
      &lt;attribute name="attr" /&gt;
    &lt;/group&gt;
  &lt;/mixed&gt;
&lt;/element&gt;
</PRE>
<P>
  As you see, you have to use the ExpressionPool to create a tree of 
  "Expression". All the primitive operators are immutable.
</P>
<P>
  Also, all associative operators like choice and sequence are binary (they 
  can only have two operands): to create an expression of (A|B|C), create 
  (A|(B|C)) or ((A|B)|C). For more, see javadoc of ExpressionPool.
</P>
<P>
  A named expression can be created as follows:
</P>
<PRE>
{
  TREXPatternPool pool = new TREXPatternPool();
  TREXGrammar g = new TREXGrammar(pool); // create an empty grammar
  
  g.start = pool.createZeroOrMore( g.namedPatterns.getOrCreate("label") );
  
  g.namedPatterns.getOrCreate("label").exp =
      pool.createChoice( ... ); // whatever expression you like
}
</PRE>
<P>
  You can refer to the named expression before the actual 
  definition is provided. It is the responsibility of the application to
  ensure that every named expression has a definition.
  The grammar created by this example is equivalent to the following TREX pattern:
</P>
<PRE><XMP>
<grammar>
  <start>
    <zeroOrMore>
      <ref name="label" />
    </zeroOrMore>
  </start>
  <define name="label">
    <choice>
      ...
    </choice>
  </define>
</grammar>
</XMP></PRE>
<P>To create a RELAX AGM, use RELAXGrammar and RELAXModule as a starting point.</P>


<A id="agm_access" />
<H2>Accessing AGM</H2>
<P>One feature that you may find useful is the "visitor" design pattern support. You 
can write your own visitor by implementing ExpressionVisitor. See javadoc of 
ExpressionVisitor for details.</P>
<P>
  Usually, this is the easiest way to access AGM
</P>

<A id="agm_modify" />
<H2>Manipulating AGM</H2>
<P>Due to the immutability of the AGM, you cannot "modify" an AGM. Instead, you
create a modified AGM. To do this, use ExpressionCloner. The following example 
creates a new AGM that changes ChoiceExp to SequenceExp and SequenceExp to ChoiceExp.
</P>
<PRE>
class SwitchChoiceAndSequence extends com.sun.msv.grammar.ExpressionCloner {

  private ExpressionPool pool;

  public Expression onSequence( SequenceExp exp ) {
    return pool.createChoice( exp.exp1, exp.exp2 );
  }
  public Expression onChoice( ChoiceExp exp ) {
    return pool.createSequence( exp.exp1, exp.exp2 );
  }
}

// usage
Expression modifiedExp = originalExp.visit( new SwitchChoiceAndSequence() );
</PRE>
<P>
   See javadoc of ExpressionCloner for details. For expressions that may contain TREX
  primitives (interleave and concur), you have to also implement TREXPatternVisitorExpression.
</P>


<A id="controller" />
<H1>Controlling Parsing of Schemata</H1>

<P>
  Any application can use GrammarReaderController to control how a grammar is parsed.
  For example, it can
</P>
<UL>
  <LI>receive errors and warnings encountered during the parsing
  <LI>prohibit inclusions
  <LI>resolve inclusion to a different source.</LI>     
</UL>

<P>
  See GrammarReaderController and IgnoreController for details.
</P>


<A id="validate" />
<H1>Validating Documents</H1>

<A id="vgm" />
<H2>Validation Grammar Model (VGM)</H2>
<P>
  To validate documents with a AGM, you have to "wrap" it in a VGM.
  VGM can be understood as an abstraction of AGM for the validator.
</P>
<P>
  VGM is a simple model which consists of two interfaces only: Acceptor and DocumentDeclaration.
  Any VGM implementation can be used as long as it implements them.
</P>
<P>
  Currently, only one VGM implementation is available, which is placed under
  the <code>com.sun.msv.verifier.regexp</code> package.
</P>
<P>
  The following example creates a RegExp VGM from a <code>Grammar</code> object.
  <code>Grammar</code> is an interface implemented by 
  RELAXGrammar, RELAXModule, TREXGrammar, and XMLSchemaGrammar.
</P>
<PRE>
import com.sun.msv.verifier.regexp.trex.TREXDocumentDeclaration;
import com.sun.msv.grammar.Grammar;

DocumentDeclaration createVGM( Grammar g ) {
  return new TREXDocumentDeclaration(g);
}
</PRE>
<P>
  Alternatively, you can pass an arbitrary expression as the first parameter
  and a newly created pool as the second parameter.
</P>
<PRE>
DocumentDeclaration createVGM( Expression exp ) {
  return new TREXDocumentDeclaration( exp, new TREXPatternPool() );
}
</PRE>


<A id="thread" />
<H2>Multithreaded Environment</H2>
<P>
  AGM is thread-safe because it is immutable.
  A thread can safely use an AGM parsed by a different thread;
  or two threads can safely share the same AGM.
  ExpressionPool is also thread-safe. Multiple threads can share
  the same pool, which is created by another thread.
</P>
<P>
  VGM, on the other hand, is not thread-safe. Each thread has to
  create its own VGM and use its own. You should never share a VGM
  between threads.
  Verifier is another thread-<b>un</b>safe component. Also, it's not
  reentrant, so you can only use one object to validate one document at a time.
</P>
<P>
  When a new expression is found, it is stored to the pool. To do this,
  a thread has to acquire a lock. And the pool is very frequently called
  during validation. So you might think that sharing a pool might cause a
  performance bottleneck.
</P>
<P>
  However, a casual experiment shows that this is not always the case.
  Yes, a thread has to acquire a lock to modify the pool, but this update
  can be done concurrently while other threads read the pool. And update
  is far less frequent than retrieval.
  So please benchmark by yourself if you need to achieve the optimal performance.
</P>


<A id="daemon" />
<H2>Daemon Process</H2>
<P>
  Generally, it's a good practice to keep re-using the same ExpressionPool.
  Using the same pool makes it bigger, and
  a bigger pool contains more expressions, which in turn results in faster validation.
</P>
<P>
  If you keep using the same ExpressionPool, it gradually expands.
  Its expansion is like a square-root function. It grows rapidly at first,
  but its growth becomes slower and slower as time goes by.
</P>
<P>
  Its size will eventually reach a certain limit, and the growth stops there.
  If your schema is DTD, RELAX, TREX without &lt;interleave&gt;, or W3C XML Schema without &lt;all&gt;,
  then this size limit is mostly moderate,
  so you can keep using the same pool forever.
</P>
<P>
  However, if a grammar is TREX with &lt;interleave&gt; patterns,
  or W3C XML Schema with &lt;all&gt;s,
  then the upper bound of a pool could be exponential to the size of the grammar
  (especially if interleave/all contains large patterns).
  If this is the case, and your application runs 24/7 as a daemon process,
  then you should occasionally throw away the pool
  to prevent its size from expanding indefinitely.
</P>
<P>
  Note that pool expansion is slow; the size of a pool is proportional to the number of validated
  documents even in the worst case. So usually it takes quite a long time to make a pool explode.
</P>
<P>
  To throw away ExpressionPool, simply create a new VGM with a brand-new pool, like this.
</P>
<PRE>
DocumentDeclaration vgm = new TREXDocumentDeclaration( grammar.getTopLevel(), new TREXPatternPool() );
</PRE>



<A id="type" />
<H1>Type Assignment</H1>
<P>
  MSV can report the element declaration which is applied to the current element,
  and what datatype is applied to text.
  This information is useful for deciding what to do with the reported element.
</P>
<P>
  To retrieve these information, call the <code>getCurrentElementType</code> method of Verifier class.
  This method returns the correct value only
  when called immediately after it processed the startElement method.
  If you are using <code>com.sun.msv.verifier.VerifierFilter</code>,
  then you can call this method only in your handler's startElement method.
</P>
<P>
  The following code illustrates how to retrieve RELAX "label" from your
  own ContentHandler.
</P>
<PRE>
void startElement( .... )
{// SAX startElement event

  ElementRule er = (ElementRule)currentVerifier.getCurrentElementType();
  if( er==null )
    // this may happen when the schema is complex.
    // MSV is unable to determine label/role at this moment.
  else
  {
    // er holds a reference to ElementRule object which is applied to this element.
    
    if(er.getParent()==null )
      // this element is declared by inline &lt;element&gt; declaration.
      // so it doesn't have any role/label
    else
    {
      final String label = er.getParent().name; // obtain label name
      final String role = er.clause.name; // obtain role name
      
      ....
    }
  }
  
  ...
}
</PRE>


<A id="trexext" />
<H2>TREX extension</H2>
<P>
  TREX doesn't have a mechanism to name the &lt;element&gt; pattern. Therefore,
  MSV introduces a proprietary extension to TREX that provides this naming mechanism.
</P>
<P>
  Annotation is done by adding a "label" attribute to the &lt;element&gt; pattern.
  The "label" attribute has to be in the "<code>http://www.sun.com/xml/msv/trex-type</code>"
  namespace. These attributes will be ignored by other TREX validating processors.
</P>
<PRE><XMP>
<grammar xmlns:ext="http://www.sun.com/xml/msv/trex-type">
  <start>
    <element ext:label="rootLabel" name="root">
      ...
      <element name="child"> <!-- label attribute is optional -->
        ...
      </element>
    </element>
  </start>
</grammar>
</XMP></PRE>

<P>
  The following example illustrates how to load an annotated TREX pattern.
</P>
<PRE>
TREXGrammarReader reader = new TREXGrammarReader(
    myGrammarReaderControllerObject,
    saxParserFactory,
    new com.sun.msv.reader.trex.typed.TypedTREXGrammarInterceptor(),
    new TREXPatternPool() );
((XMLReader)reader).parse(schemaFileName);

// obtain parsed grammar object. it returns null in case of error
TREXGrammar grammar = reader.getResult();
</PRE>
<P>
  The following example shows how to access TREX "label" information from your ContentHandler.
</P>
<PRE>
import com.sun.msv.grammar.trex.typed.TypedElementPattern;

void startElement( .... )
{// SAX startElement event

  Object o = currentVerifier.getCurrentElementType();
  if( o==null )
    // this may happen when the schema is complex.
    // MSV is unable to determine label/role at this moment.
  else
  if( o instanceod TypedElementPattern )
  {
    // the current element declaration has label attribute.
    
    final String label = ((TypedElementPattern)o).label;
      
    ....
  }
  else
    // the current element declaration has no label attribute.
  
  ...
}
</PRE>


</BODY></HTML>
